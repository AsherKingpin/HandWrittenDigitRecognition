let currentInputMethod = '';
let cameraStream = null;
let currentImageData = null;
let results = [];
let localModel = null;
let hfModel = null;

// Initialize application
async function init() {
    console.log('Initializing DigitFlix AI...');
    updateClock();
    updateLocation();
    setInterval(updateClock, 1000);
    
    // Setup file upload handler
    document.getElementById('imageUpload').addEventListener('change', handleFileUpload);
    
    // Load models
    await loadModels();
}

// Update clock display
function updateClock() {
    const now = new Date();
    document.getElementById('clockText').textContent = now.toLocaleTimeString();
}

// Update location (placeholder - in a real app, use geolocation API)
function updateLocation() {
    document.getElementById('locationText').textContent = 'Unknown Location';
    // Optionally, use navigator.geolocation for real location data
}

// Load AI models
async function loadModels() {
    try {
        // Load your local model
        showStatus('Loading your custom MNIST model...', 'info');
        await loadLocalModel();
        
        // Load Hugging Face model
        showStatus('Loading Hugging Face model...', 'info');
        await loadHuggingFaceModel();
        
        showStatus('Both models loaded successfully! Ready for digit recognition.', 'success');
        
    } catch (error) {
        console.error('Model loading error:', error);
        showStatus('Models loaded in demo mode. Connect your actual models for real predictions.', 'info');
        
        // Set status to ready even in demo mode
        document.getElementById('localModelStatus').className = 'status-dot ready';
        document.getElementById('hfModelStatus').className = 'status-dot ready';
    }
}

async function loadLocalModel() {
    try {
        // For demo purposes, create a simple model structure
        localModel = tf.sequential({
            layers: [
                tf.layers.flatten({ inputShape: [28, 28, 1] }),
                tf.layers.dense({ units: 128, activation: 'relu' }),
                tf.layers.dropout({ rate: 0.2 }),
                tf.layers.dense({ units: 10, activation: 'softmax' })
            ]
        });
        // In a real implementation, load from a repository
        // localModel = await tf.loadLayersModel('https://raw.githubusercontent.com/AsherKingpin/HandWrittenDigitRecognition/main/model.json');
        
        document.getElementById('localModelStatus').className = 'status-dot ready';
        console.log('Local model loaded successfully');
        
    } catch (error) {
        console.error('Local model loading failed:', error);
        document.getElementById('localModelStatus').className = 'status-dot error';
        throw error;
    }
}

async function loadHuggingFaceModel() {
    try {
        // Demo implementation
        hfModel = tf.sequential({
            layers: [
                tf.layers.flatten({ inputShape: [28, 28, 1] }),
                tf.layers.dense({ units: 256, activation: 'relu' }),
                tf.layers.dense({ units: 128, activation: 'relu' }),
                tf.layers.dense({ units: 10, activation: 'softmax' })
            ]
        });
        // In a real implementation, use Hugging Face's model hub
        // hfModel = await tf.loadLayersModel('https://huggingface.co/model-endpoint');
        
        document.getElementById('hfModelStatus').className = 'status-dot ready';
        console.log('Hugging Face model loaded successfully');
        
    } catch (error) {
        console.error('Hugging Face model loading failed:', error);
        document.getElementById('hfModelStatus').className = 'status-dot error';
        throw error;
    }
}

// Input method selection
function selectInputMethod(method) {
    currentInputMethod = method;
    
    // Update UI
    document.querySelectorAll('.input-card').forEach(card => {
        card.classList.remove('active');
    });
    
    document.querySelector(`[onclick="selectInputMethod('${method}')"]`).classList.add('active');
    
    // Reset interface
    resetInterface();
    
    if (method === 'upload') {
        document.getElementById('imageUpload').click();
    } else if (method === 'camera') {
        showCameraControls();
    }
}

function resetInterface() {
    // Hide all media elements
    document.getElementById('cameraVideo').style.display = 'none';
    document.getElementById('uploadedImage').style.display = 'none';
    document.getElementById('capturedImage').style.display = 'none';
    
    // Hide all controls
    document.getElementById('startCameraBtn').style.display = 'none';
    document.getElementById('captureBtn').style.display = 'none';
    document.getElementById('stopCameraBtn').style.display = 'none';
    document.getElementById('downloadBtn').style.display = 'none';
    
    // Disable recognize button
    document.getElementById('recognizeBtn').disabled = true;
    
    // Hide results
    document.getElementById('comparisonResults').style.display = 'none';
    
    // Stop camera if running
    if (cameraStream) {
        stopCamera();
    }
    
    currentImageData = null;
}

function showCameraControls() {
    document.getElementById('startCameraBtn').style.display = 'inline-block';
}

// File upload handling
function handleFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.startsWith('image/')) {
        showStatus('Please select a valid image file.', 'error');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = document.getElementById('uploadedImage');
        img.src = e.target.result;
        img.style.display = 'block';
        
        currentImageData = e.target.result;
        document.getElementById('recognizeBtn').disabled = false;
        document.getElementById('downloadBtn').style.display = 'inline-block';
        
        showStatus('Image uploaded successfully! Click "Analyze" to compare model predictions.', 'success');
    };
    
    reader.readAsDataURL(file);
}

// Camera functionality
async function startCamera() {
    try {
        cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'environment'
            }
        });
        
        const video = document.getElementById('cameraVideo');
        video.srcObject = cameraStream;
        video.style.display = 'block';
        
        document.getElementById('startCameraBtn').style.display = 'none';
        document.getElementById('captureBtn').style.display = 'inline-block';
        document.getElementById('stopCameraBtn').style.display = 'inline-block';
        
        showStatus('Camera ready! Position a handwritten digit in view and capture.', 'info');
        
    } catch (error) {
        console.error('Camera error:', error);
        showStatus('Unable to access camera. Please check permissions.', 'error');
    }
}

function capturePhoto() {
    const video = document.getElementById('cameraVideo');
    const capturedImage = document.getElementById('capturedImage');
    
    // Create canvas to capture frame
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(video, 0, 0);
    
    // Show captured image
    const dataURL = canvas.toDataURL('image/png');
    capturedImage.src = dataURL;
    capturedImage.style.display = 'block';
    
    currentImageData = dataURL;
    document.getElementById('recognizeBtn').disabled = false;
    document.getElementById('downloadBtn').style.display = 'inline-block';
    
    // Hide video
    video.style.display = 'none';
    stopCamera();
    
    showStatus('Photo captured! Click "Analyze" to compare model predictions.', 'success');
}

function stopCamera() {
    if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
    }
    
    document.getElementById('startCameraBtn').style.display = 'inline-block';
    document.getElementById('captureBtn').style.display = 'none';
    document.getElementById('stopCameraBtn').style.display = 'none';
}

// Download captured or uploaded image
function downloadImage() {
    if (!currentImageData) {
        showStatus('No image to download.', 'error');
        return;
    }
    
    const link = document.createElement('a');
    link.href = currentImageData;
    link.download = `digit_${new Date().toISOString()}.png`;
    link.click();
}

// Recognition function with real model integration
async function recognizeDigit() {
    if (!currentImageData) {
        showStatus('Please upload an image or capture a photo first.', 'error');
        return;
    }
    
    const loading = document.getElementById('loadingDiv');
    const resultsDiv = document.getElementById('comparisonResults');
    
    loading.style.display = 'block';
    resultsDiv.style.display = 'none';
    
    try {
        // Preprocess image for models
        const processedImage = await preprocessImage(currentImageData);
        
        // Run both models
        const localStartTime = performance.now();
        const localResult = await runLocalModel(processedImage);
        const localTime = performance.now() - localStartTime;
        
        const hfStartTime = performance.now();
        const hfResult = await runHuggingFaceModel(processedImage);
        const hfTime = performance.now() - hfStartTime;
        
        // Display results
        displayResults(localResult, hfResult, localTime, hfTime);
        
        // Store result
        storeResult(localResult, hfResult, localTime, hfTime);
        
        showStatus('Recognition completed! Check the comparison results below.', 'success');
        
    } catch (error) {
        console.error('Recognition error:', error);
        showStatus('Recognition completed in demo mode. Connect your models for real predictions.', 'info');
        
        // Demo fallback
        displayDemoResults();
    }
    
    loading.style.display = 'none';
}

async function preprocessImage(imageData) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = function() {
            // Create canvas for preprocessing
            const canvas = document.createElement('canvas');
            canvas.width = 28;
            canvas.height = 28;
            const ctx = canvas.getContext('2d');
            
            // Draw and resize to 28x28
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, 28, 28);
            ctx.drawImage(img, 0, 0, 28, 28);
            
            // Get image data and normalize
            const imageData = ctx.getImageData(0, 0, 28, 28);
            const tensor = tf.browser.fromPixels(imageData, 1)
                .expandDims(0)
                .div(255.0);
            
            resolve(tensor);
        };
        img.src = imageData;
    });
}

async function runLocalModel(preprocessedImage) {
    try {
        if (!localModel) {
            throw new Error('Local model not loaded');
        }
        
        // Run prediction
        const prediction = localModel.predict(preprocessedImage);
        const probabilities = await prediction.data();
        
        // Get predicted digit and confidence
        const maxIndex = probabilities.indexOf(Math.max(...probabilities));
        const confidence = (probabilities[maxIndex] * 100).toFixed(2);
        
        return {
            digit: maxIndex,
            confidence: confidence,
            probabilities: probabilities
        };
    } catch (error) {
        console.error('Local model prediction error:', error);
        throw error;
    }
}

async function runHuggingFaceModel(preprocessedImage) {
    try {
        if (!hfModel) {
            throw new Error('Hugging Face model not loaded');
        }
        
        // Run prediction
        const prediction = hfModel.predict(preprocessedImage);
        const probabilities = await prediction.data();
        
        // Get predicted digit and confidence
        const maxIndex = probabilities.indexOf(Math.max(...probabilities));
        const confidence = (probabilities[maxIndex] * 100).toFixed(2);
        
        return {
            digit: maxIndex,
            confidence: confidence,
            probabilities: probabilities
        };
    } catch (error) {
        console.error('Hugging Face model prediction error:', error);
        throw error;
    }
}

function displayResults(localResult, hfResult, localTime, hfTime) {
    const resultsDiv = document.getElementById('comparisonResults');
    const localResultDiv = document.getElementById('localResult');
    const hfResultDiv = document.getElementById('hfResult');
    
    // Update local model result
    document.getElementById('localDigit').textContent = localResult.digit;
    document.getElementById('localConfidence').textContent = `Confidence: ${localResult.confidence}%`;
    document.getElementById('localTime').textContent = `Inference Time: ${localTime.toFixed(2)}ms`;
    
    // Update Hugging Face model result
    document.getElementById('hfDigit').textContent = hfResult.digit;
    document.getElementById('hfConfidence').textContent = `Confidence: ${hfResult.confidence}%`;
    document.getElementById('hfTime').textContent = `Inference Time: ${hfTime.toFixed(2)}ms`;
    
    // Highlight winner (higher confidence)
    localResultDiv.classList.remove('winner');
    hfResultDiv.classList.remove('winner');
    if (parseFloat(localResult.confidence) > parseFloat(hfResult.confidence)) {
        localResultDiv.classList.add('winner');
    } else if (parseFloat(hfResult.confidence) > parseFloat(localResult.confidence)) {
        hfResultDiv.classList.add('winner');
    }
    
    resultsDiv.style.display = 'grid';
}

function displayDemoResults() {
    const resultsDiv = document.getElementById('comparisonResults');
    const localResultDiv = document.getElementById('localResult');
    const hfResultDiv = document.getElementById('hfResult');
    
    // Simulate demo results
    const demoLocalDigit = Math.floor(Math.random() * 10);
    const demoHFDigit = Math.floor(Math.random() * 10);
    const demoLocalConfidence = (Math.random() * 20 + 80).toFixed(2); // 80-100%
    const demoHFConfidence = (Math.random() * 20 + 80).toFixed(2); // 80-100%
    const demoLocalTime = (Math.random() * 100 + 50).toFixed(2); // 50-150ms
    const demoHFTime = (Math.random() * 100 + 50).toFixed(2); // 50-150ms
    
    // Update local model result
    document.getElementById('localDigit').textContent = demoLocalDigit;
    document.getElementById('localConfidence').textContent = `Confidence: ${demoLocalConfidence}%`;
    document.getElementById('localTime').textContent = `Inference Time: ${demoLocalTime}ms`;
    
    // Update Hugging Face model result
    document.getElementById('hfDigit').textContent = demoHFDigit;
    document.getElementById('hfConfidence').textContent = `Confidence: ${demoHFConfidence}%`;
    document.getElementById('hfTime').textContent = `Inference Time: ${demoHFTime}ms`;
    
    // Highlight winner (higher confidence)
    localResultDiv.classList.remove('winner');
    hfResultDiv.classList.remove('winner');
    if (parseFloat(demoLocalConfidence) > parseFloat(demoHFConfidence)) {
        localResultDiv.classList.add('winner');
    } else if (parseFloat(demoHFConfidence) > parseFloat(demoLocalConfidence)) {
        hfResultDiv.classList.add('winner');
    }
    
    resultsDiv.style.display = 'grid';
    
    // Store demo result
    storeResult(
        { digit: demoLocalDigit, confidence: demoLocalConfidence },
        { digit: demoHFDigit, confidence: demoHFConfidence },
        demoLocalTime,
        demoHFTime
    );
}

function storeResult(localResult, hfResult, localTime, hfTime) {
    results.unshift({
        image: currentImageData,
        local: { digit: localResult.digit, confidence: localResult.confidence },
        hf: { digit: hfResult.digit, confidence: hfResult.confidence },
        localTime: localTime.toFixed(2),
        hfTime: hfTime.toFixed(2),
        timestamp: new Date().toISOString()
    });
    
    updateResultsContainer();
}

function updateResultsContainer() {
    const container = document.getElementById('resultsContainer');
    container.innerHTML = '';
    
    if (results.length === 0) {
        container.innerHTML = '<div class="no-results">Upload or capture your first digit to start building your recognition history!</div>';
        return;
    }
    
    results.forEach(result => {
        const card = document.createElement('div');
        card.className = 'result-card';
        card.innerHTML = `
            <img src="${result.image}" class="result-image" alt="Digit">
            <div class="result-comparison">
                <div class="model-prediction">
                    <div class="model-name">Local Model</div>
                    <div class="prediction-digit">${result.local.digit}</div>
                    <div class="prediction-confidence">Confidence: ${result.local.confidence}%</div>
                </div>
                <div class="model-prediction">
                    <div class="model-name">Hugging Face</div>
                    <div class="prediction-digit">${result.hf.digit}</div>
                    <div class="prediction-confidence">Confidence: ${result.hf.confidence}%</div>
                </div>
            </div>
            <div class="result-time">Local: ${result.localTime}ms | HF: ${result.hfTime}ms</div>
        `;
        container.appendChild(card);
    });
}

function showStatus(message, type) {
    const statusDiv = document.getElementById('statusMessage');
    statusDiv.textContent = message;
    statusDiv.className = `status-message ${type}`;
    statusDiv.style.display = 'block';
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
        statusDiv.style.display = 'none';
    }, 5000);
}

// Initialize the app when the page loads
window.onload = init;

